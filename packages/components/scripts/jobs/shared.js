/* eslint-disable no-console */
import fs from 'fs/promises';
import fsSync from 'fs';
import path from 'path';
import url from 'url';
import { exec } from 'child_process';
import util from 'util';
import { deleteAsync } from 'del';
import { globby } from 'globby';
import chalk from 'chalk';
import ora from 'ora';
import { pascalCase } from 'change-case';

const spinner = ora({ hideCursor: false });

/**
 * Sort function, used to sort components by name
 * @param {Object} a Component A
 * @param {Object} b Component B
 * @returns Sorted object
 */
const sortByComponentName = (a, b) => {
  const nameA = a.name.toUpperCase();
  const nameB = b.name.toUpperCase();
  if (nameA < nameB) return -1;
  if (nameA > nameB) return 1;
  return 0;
};

/**
 * Create a job that when run executes the given actions
 * @param {String} label The label to show
 * @param {Function} action The action to run
 * @returns {Function} A function with bound arguments useable in the build pipeline
 */
export const job = (label, action) => async (...args) => {
  spinner.text = label;
  spinner.start();

  try {
    await action(...args);
    spinner.stop();
    console.log(`${chalk.green('âœ”')} ${label}`);
  } catch (err) {
    spinner.stop();
    console.error(`${chalk.red('âœ˜')} ${err}`);
    if (err.stdout) console.error(chalk.red(err.stdout));
    if (err.stderr) console.error(chalk.red(err.stderr));
    process.exit(1);
  }
};

/**
 * Creates an async version of exec
 */
export const execPromise = util.promisify(exec);

/**
 * Get the absolute path of one to many path parts,
 * relative to the `components/scripts` directory
 *
 * @param {String} wantedPath
 * @returns {String} The absolute path to the components/scripts directory
 */
export const getPath = (wantedPath) => path.join(
  path.dirname(path.join(url.fileURLToPath(import.meta.url), '..')),
  wantedPath,
);

/**
 * Sync the package.json version field located in outputPackageDir
 * with the one provided from componentsPackageDir
 * @param {string} label The label
 * @returns {job}
 */
export const runAdjustPackageVersion = (label) => job(label, async (
  componentsPackageDir,
  outputPackageDir,
) => {
  // Get the version field from the components package.json
  const componentPackageAsString = await fs.readFile(path.join(componentsPackageDir, 'package.json'), {
    encoding: 'utf-8',
  });
  const { version } = JSON.parse(componentPackageAsString);

  // Get the react packages package.json
  const reactPackageAsString = await fs.readFile(path.join(outputPackageDir, 'package.json'));
  const reactPackageAsJSON = JSON.parse(reactPackageAsString);

  // Write out the changed package.json file with adjusted version
  return await fs.writeFile(
    path.join(outputPackageDir, 'package.json'),
    [
      JSON.stringify({ ...reactPackageAsJSON, version }, null, 2).trim(),
      '',
    ].join('\n'),
  );
});

/**
 * Prepares directories by removing them and creating them anew
 * @param {string} label The label to use
 * @returns {job}
 */
export const createRunPrepare = (label) => job(label, async (...dirs) => {
  // Remove all directories
  await Promise.all(
    dirs.map(dir => deleteAsync(dir, { force: true })),
  );

  // Create all directories
  await Promise.all(
    dirs.map(dir => fs.mkdir(dir, {
      recursive: true,
    })),
  );
});

/**
 * Creates a framework header that will be used to prepend on generated files
 * @param {string} framework The framework to use
 * @returns {string} The generated header
 */
export const createHeader = framework => `
// ---------------------------------------------------------------------
// ðŸ”’ AUTOGENERATED @synergy-design-system/${framework} wrappers for @synergy-design-system/components
// Please do not edit this file directly!
// It will get recreated when running pnpm build.
// ---------------------------------------------------------------------   
`.trim();

/**
 * Get the complete list of exports from the file system
 * @param {boolean} warn Show warning messages when skipping an entry?
 */
export const getExportsListFromFileSystem = async (warn = false) => {
  const componentsDir = getPath('../src/components');

  // Only treat components as available if there is a COMPONENTNAME.component.ts!
  const foundComponents = await globby(`${componentsDir}/**/*.component.ts`);

  return foundComponents
    .sort()
    .map(c => c.split('/').at(-1))
    .map(c => c.replace(/\.component\.ts$/, ''))
    .map(c => ({
      componentAbsolutePath: path.join(
        componentsDir,
        c,
        `${c}.ts`,
      ),
      componentClass: pascalCase(`Syn-${c}`),
      componentImportPath: path.join('components', c, `${c}.js`),
      componentName: c,
    }))
    .filter(c => {
      const available = fsSync.existsSync(c.componentAbsolutePath);

      // Make sure to warn user if it seems we missed an export
      if (!available && warn) {
        console.warn(`\n${chalk.yellow('âš ')} Warning: Not exporting component <${c.componentName} /> as there is no export file found. Please create ${c.componentAbsolutePath} to export this file`);
      }

      return available;
    });
};

/**
 * Get all available components out of the metadata
 * @param {object} metadata Metadata, usually from components.json
 * @returns {array} List of components
 */
export const getAllComponents = async (metadata) => {
  const allComponents = [];

  const exportedComponents = await getExportsListFromFileSystem(false);
  const exportedComponentsWithoutPrefix = exportedComponents.map(c => c.componentName);

  metadata.modules.forEach(module => {
    module.declarations?.forEach(declaration => {
      if (declaration.customElement) {
        const component = declaration;
        if (component && exportedComponentsWithoutPrefix.includes(component.tagNameWithoutPrefix)) {
          allComponents.push(Object.assign(component, {
            path: module.path,
          }));
        }
      }
    });
  });

  // Make sure to always sort alphabetically as this will otherwise trigger bad effects
  const sortedComponents = [...allComponents].sort(sortByComponentName);

  return sortedComponents;
};

/**
 * Create a function that uppercases or lowercases the first letter of its argument
 * @param {string} method The method to use. May be toLowerCase or toUpperCase
 * @returns {function} A function that will either lower or uppercase the first letter
 */
export const changeFirstLetter = method => string => string.charAt(0)[method]() + string.slice(1);

/**
 * Lower case the first letter of string
 * @param {string} Input string
 * @returns {string}
 */
export const lcFirstLetter = changeFirstLetter('toLowerCase');

/**
 * Upper case the first letter
 * @param {string} Input string
 * @returns {string}
 */
export const ucFirstLetter = changeFirstLetter('toUpperCase');

/**
 * Creates a string that represents the index.js file for all components
 * @param {string} headerComment Comment to prefix
 * @param {object[]} Array of name and output path objects
 * @returns {string} The index.js output
 */
export const createFrameworkIndex = (headerComment, components = []) => {
  // Always sort the included scripts as otherwise we would have unneeded index.js changes
  // due to the fact that the order is not treated well
  const alphabeticIndex = [...components]
    .sort(sortByComponentName)
    .map(({ name, outputPath }) => `export { ${name} } from '${outputPath}';`);

  return [
    headerComment,
    alphabeticIndex.join('\n'),
    '',
  ].join('\n');
};
